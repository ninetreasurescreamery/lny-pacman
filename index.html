<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<title>Pacman: Nine Treasures Creamery x AI-Pilled Asians in Tech</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  background: #000;
  overflow: hidden;
  touch-action: none;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}
#gameCanvas {
  display: block;
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
// ==========================================
// CONSTANTS & CONFIG
// ==========================================
const TILE = 16;
const COLS = 21;
const ROWS = 17;
const MAZE_W = COLS * TILE;       // 448
const MAZE_H = ROWS * TILE;       // 496
const HUD_TOP = 40;
const HUD_BOT = 40;
const CANVAS_W = MAZE_W;
const CANVAS_H = MAZE_H + HUD_TOP + HUD_BOT;
const FRAME_TIME = 1000 / 60;

const COLORS = {
  pacman: '#00FFFF',
  ghostPink: '#FFB6C1',
  ghostPeach: '#FFDAB9',
  ghostMint: '#98FF98',
  ghostYellow: '#FFFACD',
  ghostFrightened: '#0000FF',
  ghostFrightenedFlash: '#FFFFFF',
  ghostEyes: '#FFFFFF',
  ghostPupil: '#0000FF',
  wall: '#1E90FF',
  dot: '#FFFFFF',
  powerPill: '#FFD700',
  background: '#000000',
  text: '#FFFFFF',
  textCyan: '#00FFFF',
};

// Game states
const STATE = {
  LOGO: 'LOGO',
  SPLASH: 'SPLASH',
  EXPLAINER: 'EXPLAINER',
  LEVEL_SPLASH: 'LEVEL_SPLASH',
  READY: 'READY',
  PLAYING: 'PLAYING',
  PACMAN_DEATH: 'PACMAN_DEATH',
  LEVEL_COMPLETE: 'LEVEL_COMPLETE',
  GAME_OVER: 'GAME_OVER',
  SCORE_SCREEN: 'SCORE_SCREEN',
  WIN: 'WIN',
  CREDITS: 'CREDITS',
  END: 'END',
};

// Directions
const DIR = {
  NONE: -1,
  UP: 0,
  LEFT: 1,
  DOWN: 2,
  RIGHT: 3,
};

const DIR_VEC = {
  [DIR.UP]: { x: 0, y: -1 },
  [DIR.LEFT]: { x: -1, y: 0 },
  [DIR.DOWN]: { x: 0, y: 1 },
  [DIR.RIGHT]: { x: 1, y: 0 },
};

const OPPOSITE = {
  [DIR.UP]: DIR.DOWN,
  [DIR.DOWN]: DIR.UP,
  [DIR.LEFT]: DIR.RIGHT,
  [DIR.RIGHT]: DIR.LEFT,
};

// Ghost modes
const GHOST_MODE = {
  SCATTER: 'SCATTER',
  CHASE: 'CHASE',
  FRIGHTENED: 'FRIGHTENED',
  EATEN: 'EATEN',
  HOUSE: 'HOUSE',
  LEAVING: 'LEAVING',
};

// Tile types
const T = {
  EMPTY: 0,
  WALL: 1,
  DOT: 2,
  POWER: 3,
  GHOST_HOUSE: 4,
  GHOST_DOOR: 5,
  TUNNEL: 6,
};

// ==========================================
// LEVEL CONFIGURATIONS
// ==========================================
// 1=wall, 2=dot, 3=power pill, 0=empty, 4=ghost house, 5=ghost door, 6=tunnel
// All mazes: 21x17, ghost house rows 5-8 cols 9-12, door (10,4), tunnels row 6 cols 0/20, Pacman spawn (10,13)
const LEVEL_CONFIGS = [
  {
    name: 'Malted Toasted Rice',
    image: 'level1.png',
    scoopColor: '#D4A574',
    wallColor: '#1E90FF',
    speedMultiplier: 0.55,
    frightenedDuration: 360,
    ghostDotLimits: [0, 0, 5, 15],
    maze: [
      '111111111111111111111',
      '132222222222222222231',
      '122222222222222222221',
      '122222222222222222221',
      '122222211151112222221',
      '122222210444102222221',
      '600000010444100000006',
      '122222210444102222221',
      '122222211111112222221',
      '122222222222222222221',
      '122222222222222222221',
      '132222222222222222231',
      '122222222222222222221',
      '122222222222222222221',
      '122222222222222222221',
      '122222222222222222221',
      '111111111111111111111',
    ],
  },
  {
    name: 'Black Sesame Cookies & Cream',
    image: 'level2.png',
    scoopColor: '#333333',
    wallColor: '#8B5CF6',
    speedMultiplier: 0.70,
    frightenedDuration: 270,
    ghostDotLimits: [0, 0, 5, 12],
    maze: [
      '111111111111111111111',
      '132222222222222222231',
      '121211122222221121121',
      '122222222222222222221',
      '121222211151112222121',
      '122222210444102222221',
      '600000010444100000006',
      '122222210444102222221',
      '121222211111112222121',
      '122222222222222222221',
      '121211122222221121121',
      '132222222222222222231',
      '121222211111112222121',
      '122222222222222222221',
      '121222222222222222121',
      '122222222222222222221',
      '111111111111111111111',
    ],
  },
  {
    name: 'Miso Maple Ginger',
    image: 'level3.png',
    scoopColor: '#C8A050',
    wallColor: '#E67E22',
    speedMultiplier: 0.85,
    frightenedDuration: 180,
    ghostDotLimits: [0, 0, 3, 8],
    maze: [
      '111111111111111111111',
      '132221222222222122231',
      '121221222222222221121',
      '122222212222122222221',
      '121122211151112211121',
      '122222210444102222221',
      '600000010444100000006',
      '122222210444102222221',
      '121122211111112211121',
      '122222212222122222221',
      '121221222222222221121',
      '132221222222222122231',
      '121222211111112222121',
      '122222222222222222221',
      '121122212222122211121',
      '122222222222222222221',
      '111111111111111111111',
    ],
  },
  {
    name: 'Kaya Toast',
    image: 'level4.png',
    scoopColor: '#7CB342',
    wallColor: '#27AE60',
    speedMultiplier: 1.00,
    frightenedDuration: 120,
    ghostDotLimits: [0, 0, 2, 5],
    maze: [
      '111111111111111111111',
      '132121222222222121231',
      '121221211221121221121',
      '122122212222122212221',
      '121222211151112222121',
      '122122210444102212221',
      '600000010444100000006',
      '122122210444102212221',
      '121222211111112222121',
      '122122212222122212221',
      '121221211221121221121',
      '132121222222222121231',
      '121221211111121221121',
      '122122222222222212221',
      '121221212222121221121',
      '122222222222222222221',
      '111111111111111111111',
    ],
  },
];

function parseMaze(strings) {
  return strings.map(row => row.split('').map(Number));
}

// ==========================================
// CANVAS SETUP
// ==========================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// High-DPI support for sharp text
const DPR = Math.min(window.devicePixelRatio || 1, 3);
canvas.width = CANVAS_W * DPR;
canvas.height = CANVAS_H * DPR;
ctx.scale(DPR, DPR);

// Load logo image
const logoImg = new Image();
logoImg.src = 'kim2.png';

// Preload level splash images
const levelImages = LEVEL_CONFIGS.map(cfg => {
  const img = new Image();
  img.src = cfg.image;
  return img;
});

// Preload sponsor logos
const SPONSORS = [
  'openai', 'linkedin', 'amazon', 'microsoft', 'yahoo',
  'squarespace', 'mastercard', 'lyft', 'peloton', 'uipath', 'taatf',
];
const sponsorImages = SPONSORS.map(name => {
  const img = new Image();
  img.src = 'companies/' + name + '.png';
  return { name, img };
});

function resizeCanvas() {
  const scaleX = window.innerWidth / CANVAS_W;
  const scaleY = window.innerHeight / CANVAS_H;
  const scale = Math.min(scaleX, scaleY);
  canvas.style.width = (CANVAS_W * scale) + 'px';
  canvas.style.height = (CANVAS_H * scale) + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Convert screen coords to canvas coords
function screenToCanvas(sx, sy) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (sx - rect.left) * (CANVAS_W / rect.width),
    y: (sy - rect.top) * (CANVAS_H / rect.height),
  };
}

// ==========================================
// SOUND MANAGER (Web Audio API)
// ==========================================
class SoundManager {
  constructor() {
    this.ctx = null;
    this.muted = false;
  }
  init() {
    if (!this.ctx) {
      try { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); }
      catch(e) { /* no audio */ }
    }
  }
  play(type) {
    if (this.muted || !this.ctx) return;
    try {
      const osc = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      osc.connect(gain);
      gain.connect(this.ctx.destination);
      const t = this.ctx.currentTime;
      switch(type) {
        case 'chomp':
          osc.type = 'square';
          osc.frequency.setValueAtTime(300, t);
          osc.frequency.setValueAtTime(200, t + 0.05);
          gain.gain.setValueAtTime(0.15, t);
          gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
          osc.start(t); osc.stop(t + 0.1);
          break;
        case 'power':
          osc.type = 'square';
          osc.frequency.setValueAtTime(500, t);
          osc.frequency.linearRampToValueAtTime(800, t + 0.2);
          gain.gain.setValueAtTime(0.15, t);
          gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
          osc.start(t); osc.stop(t + 0.3);
          break;
        case 'eatghost':
          osc.type = 'square';
          osc.frequency.setValueAtTime(200, t);
          osc.frequency.linearRampToValueAtTime(600, t + 0.15);
          gain.gain.setValueAtTime(0.15, t);
          gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
          osc.start(t); osc.stop(t + 0.2);
          break;
        case 'death':
          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(500, t);
          osc.frequency.linearRampToValueAtTime(100, t + 0.8);
          gain.gain.setValueAtTime(0.12, t);
          gain.gain.exponentialRampToValueAtTime(0.001, t + 0.8);
          osc.start(t); osc.stop(t + 0.8);
          break;
        case 'levelcomplete':
          osc.type = 'square';
          [392, 523, 659, 784].forEach((f, i) => {
            osc.frequency.setValueAtTime(f, t + i * 0.15);
          });
          gain.gain.setValueAtTime(0.15, t);
          gain.gain.exponentialRampToValueAtTime(0.001, t + 0.7);
          osc.start(t); osc.stop(t + 0.7);
          break;
        case 'start':
          osc.type = 'square';
          osc.frequency.setValueAtTime(440, t);
          osc.frequency.setValueAtTime(220, t + 0.1);
          osc.frequency.setValueAtTime(440, t + 0.2);
          gain.gain.setValueAtTime(0.12, t);
          gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
          osc.start(t); osc.stop(t + 0.3);
          break;
      }
    } catch(e) { /* ignore audio errors */ }
  }
}

const sound = new SoundManager();

// ==========================================
// INPUT MANAGER
// ==========================================
class InputManager {
  constructor() {
    this.direction = DIR.NONE;
    this.touchStartX = 0;
    this.touchStartY = 0;
    this.clickHandlers = [];
    this._setupKeyboard();
    this._setupTouch();
  }
  _setupKeyboard() {
    window.addEventListener('keydown', (e) => {
      switch(e.key) {
        case 'ArrowUp': case 'w': case 'W': this.direction = DIR.UP; e.preventDefault(); break;
        case 'ArrowDown': case 's': case 'S': this.direction = DIR.DOWN; e.preventDefault(); break;
        case 'ArrowLeft': case 'a': case 'A': this.direction = DIR.LEFT; e.preventDefault(); break;
        case 'ArrowRight': case 'd': case 'D': this.direction = DIR.RIGHT; e.preventDefault(); break;
      }
    });
  }
  _setupTouch() {
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      this.touchStartX = t.clientX;
      this.touchStartY = t.clientY;
    }, { passive: false });
    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (e.changedTouches.length === 0) return;
      const t = e.changedTouches[0];
      const dx = t.clientX - this.touchStartX;
      const dy = t.clientY - this.touchStartY;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < 20) {
        // Tap — trigger click handlers
        const pos = screenToCanvas(t.clientX, t.clientY);
        this.clickHandlers.forEach(h => h(pos.x, pos.y));
        return;
      }
      if (Math.abs(dx) > Math.abs(dy)) {
        this.direction = dx > 0 ? DIR.RIGHT : DIR.LEFT;
      } else {
        this.direction = dy > 0 ? DIR.DOWN : DIR.UP;
      }
    }, { passive: false });
    canvas.addEventListener('click', (e) => {
      const pos = screenToCanvas(e.clientX, e.clientY);
      this.clickHandlers.forEach(h => h(pos.x, pos.y));
    });
  }
  onClickOrTap(handler) {
    this.clickHandlers.push(handler);
  }
  consumeDirection() {
    const d = this.direction;
    this.direction = DIR.NONE;
    return d;
  }
  peekDirection() {
    return this.direction;
  }
}

const input = new InputManager();

// ==========================================
// SPRITE RENDERER
// ==========================================
const Sprites = {
  drawPacman(ctx, x, y, size, direction, mouthAngle) {
    ctx.save();
    ctx.translate(x, y);
    let rot = 0;
    switch(direction) {
      case DIR.RIGHT: rot = 0; break;
      case DIR.DOWN: rot = Math.PI / 2; break;
      case DIR.LEFT: rot = Math.PI; break;
      case DIR.UP: rot = -Math.PI / 2; break;
    }
    ctx.rotate(rot);
    ctx.fillStyle = COLORS.pacman;
    ctx.beginPath();
    ctx.arc(0, 0, size / 2, mouthAngle, 2 * Math.PI - mouthAngle);
    ctx.lineTo(0, 0);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  },

  drawGhost(ctx, x, y, size, color, mode, direction, frame) {
    ctx.save();
    ctx.translate(x, y);
    const r = size / 2;
    const bodyColor = mode === GHOST_MODE.FRIGHTENED
      ? (frame % 30 < 15 ? COLORS.ghostFrightened : COLORS.ghostFrightenedFlash)
      : mode === GHOST_MODE.EATEN ? 'transparent' : color;

    if (bodyColor !== 'transparent') {
      // Ghost body
      ctx.fillStyle = bodyColor;
      ctx.beginPath();
      ctx.arc(0, -r * 0.2, r, Math.PI, 0);
      ctx.lineTo(r, r);
      // Wavy bottom
      const waves = 3;
      const waveW = (2 * r) / waves;
      for (let i = 0; i < waves; i++) {
        const wx = r - i * waveW;
        const waveOffset = (frame % 20 < 10) ? 0 : waveW / 2;
        ctx.quadraticCurveTo(
          wx - waveW * 0.25, r - 4 + (i % 2 === 0 ? 3 : -3),
          wx - waveW, r
        );
      }
      ctx.closePath();
      ctx.fill();
    }

    // Eyes
    if (mode !== GHOST_MODE.FRIGHTENED || bodyColor === COLORS.ghostFrightenedFlash) {
      const eyeSize = r * 0.35;
      const pupilSize = r * 0.2;
      const eyeY = -r * 0.3;
      const eyeSpacing = r * 0.45;

      // Eye direction offset
      let pdx = 0, pdy = 0;
      switch(direction) {
        case DIR.LEFT: pdx = -pupilSize * 0.5; break;
        case DIR.RIGHT: pdx = pupilSize * 0.5; break;
        case DIR.UP: pdy = -pupilSize * 0.5; break;
        case DIR.DOWN: pdy = pupilSize * 0.5; break;
      }

      [-eyeSpacing, eyeSpacing].forEach(ex => {
        ctx.fillStyle = COLORS.ghostEyes;
        ctx.beginPath();
        ctx.arc(ex, eyeY, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = mode === GHOST_MODE.EATEN ? COLORS.ghostPupil : '#000';
        ctx.beginPath();
        ctx.arc(ex + pdx, eyeY + pdy, pupilSize, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // Frightened face (mouth)
    if (mode === GHOST_MODE.FRIGHTENED && bodyColor !== 'transparent') {
      ctx.strokeStyle = '#FFF';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      const mouthY = r * 0.2;
      for (let i = -3; i <= 3; i++) {
        const mx = i * (r / 3);
        const my = mouthY + (i % 2 === 0 ? 2 : -2);
        if (i === -3) ctx.moveTo(mx, my);
        else ctx.lineTo(mx, my);
      }
      ctx.stroke();

      // Simple white eyes for frightened
      ctx.fillStyle = '#FFF';
      [-r * 0.3, r * 0.3].forEach(ex => {
        ctx.fillRect(ex - 1.5, -r * 0.4, 3, 3);
      });
    }

    ctx.restore();
  },

  drawIceCream(ctx, x, y, size, scoopColor) {
    ctx.save();
    ctx.translate(x, y);
    const r = size * 0.35;
    // Cone
    ctx.fillStyle = '#DEB887';
    ctx.beginPath();
    ctx.moveTo(-r * 0.7, 0);
    ctx.lineTo(0, size * 0.45);
    ctx.lineTo(r * 0.7, 0);
    ctx.closePath();
    ctx.fill();
    // Cup (cyan)
    ctx.fillStyle = '#00FFFF';
    ctx.fillRect(-r * 0.8, -2, r * 1.6, 5);
    // Scoop
    ctx.fillStyle = scoopColor;
    ctx.beginPath();
    ctx.arc(0, -r * 0.3, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  },

  drawSparkle(ctx, x, y, size, frame) {
    ctx.save();
    ctx.translate(x, y);
    const pulse = 1 + 0.2 * Math.sin(frame * 0.15);
    ctx.scale(pulse, pulse);
    ctx.fillStyle = COLORS.powerPill;
    // 4-pointed star
    const r = size / 2;
    ctx.beginPath();
    for (let i = 0; i < 8; i++) {
      const angle = (i * Math.PI) / 4;
      const dist = i % 2 === 0 ? r : r * 0.35;
      ctx.lineTo(Math.cos(angle) * dist, Math.sin(angle) * dist);
    }
    ctx.closePath();
    ctx.fill();

    // Glow
    ctx.globalAlpha = 0.3;
    ctx.beginPath();
    ctx.arc(0, 0, r * 1.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  },
};

// ==========================================
// MAZE RENDERER
// ==========================================
function drawMaze(ctx, maze, frame, wallColor) {
  const offsetY = HUD_TOP;
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const tile = maze[r][c];
      const x = c * TILE;
      const y = r * TILE + offsetY;
      switch(tile) {
        case T.WALL:
          drawWallTile(ctx, maze, r, c, x, y, wallColor);
          break;
        case T.DOT:
          ctx.fillStyle = COLORS.dot;
          ctx.beginPath();
          ctx.arc(x + TILE/2, y + TILE/2, 2, 0, Math.PI * 2);
          ctx.fill();
          break;
        case T.POWER:
          Sprites.drawSparkle(ctx, x + TILE/2, y + TILE/2, TILE * 0.8, frame);
          break;
        case T.GHOST_DOOR:
          ctx.fillStyle = '#FFB8FF';
          ctx.fillRect(x, y + TILE/2 - 1, TILE, 3);
          break;
      }
    }
  }
}

function drawWallTile(ctx, maze, r, c, x, y, wallColor) {
  ctx.fillStyle = wallColor || COLORS.wall;
  // Simple but effective wall drawing using rounded rects
  const m = 1; // margin
  const isWall = (rr, cc) => {
    if (rr < 0 || rr >= ROWS || cc < 0 || cc >= COLS) return true;
    return maze[rr][cc] === T.WALL;
  };

  const up = isWall(r-1, c);
  const down = isWall(r+1, c);
  const left = isWall(r, c-1);
  const right = isWall(r, c+1);

  // Draw wall segments that connect to neighbors
  ctx.strokeStyle = wallColor || COLORS.wall;
  ctx.lineWidth = 2;

  const cx = x + TILE/2;
  const cy = y + TILE/2;

  // Draw connecting lines
  ctx.beginPath();
  if (!up && !down && !left && !right) {
    // Isolated wall block
    ctx.strokeRect(x + 3, y + 3, TILE - 6, TILE - 6);
  } else {
    if (up) { ctx.moveTo(cx, cy); ctx.lineTo(cx, y); }
    if (down) { ctx.moveTo(cx, cy); ctx.lineTo(cx, y + TILE); }
    if (left) { ctx.moveTo(cx, cy); ctx.lineTo(x, cy); }
    if (right) { ctx.moveTo(cx, cy); ctx.lineTo(x + TILE, cy); }
  }
  ctx.stroke();

  // Draw rounded corners where appropriate
  const radius = 4;
  ctx.beginPath();
  if (!up && !left && right && down) {
    ctx.arc(x + TILE, y + TILE, radius, Math.PI, Math.PI * 1.5);
  }
  if (!up && !right && left && down) {
    ctx.arc(x, y + TILE, radius, Math.PI * 1.5, Math.PI * 2);
  }
  if (!down && !left && right && up) {
    ctx.arc(x + TILE, y, radius, Math.PI * 0.5, Math.PI);
  }
  if (!down && !right && left && up) {
    ctx.arc(x, y, radius, 0, Math.PI * 0.5);
  }
  ctx.stroke();
}

// ==========================================
// PACMAN CLASS
// ==========================================
class Pacman {
  constructor() {
    this.reset();
  }
  reset() {
    // Starting position (center bottom area of maze)
    this.tileX = 10;
    this.tileY = 13;
    this.pixelX = this.tileX * TILE + TILE/2;
    this.pixelY = this.tileY * TILE + TILE/2;
    this.direction = DIR.LEFT;
    this.nextDirection = DIR.NONE;
    this.speed = 2;
    this.animFrame = 0;
    this.animTimer = 0;
    this.moving = false;
    this.alive = true;
    this.deathFrame = 0;
  }
  update(maze) {
    if (!this.alive) {
      this.deathFrame++;
      return;
    }

    this.animTimer++;
    if (this.animTimer % 3 === 0) this.animFrame = (this.animFrame + 1) % 4;

    const inputDir = input.peekDirection();
    if (inputDir !== DIR.NONE) {
      this.nextDirection = inputDir;
    }

    // Try to change direction at tile center
    const atCenterX = Math.abs(this.pixelX - (this.tileX * TILE + TILE/2)) < this.speed;
    const atCenterY = Math.abs(this.pixelY - (this.tileY * TILE + TILE/2)) < this.speed;

    if (atCenterX && atCenterY) {
      // Snap to center
      this.pixelX = this.tileX * TILE + TILE/2;
      this.pixelY = this.tileY * TILE + TILE/2;

      // Try nextDirection first
      if (this.nextDirection !== DIR.NONE && this.canMove(this.nextDirection, maze)) {
        this.direction = this.nextDirection;
        this.nextDirection = DIR.NONE;
        input.direction = DIR.NONE;
      }

      if (!this.canMove(this.direction, maze)) {
        this.moving = false;
        return;
      }
    }

    // Move in current direction
    if (this.canMovePixel(this.direction, maze)) {
      const vec = DIR_VEC[this.direction];
      this.pixelX += vec.x * this.speed;
      this.pixelY += vec.y * this.speed;
      this.moving = true;

      // Update tile position
      this.tileX = Math.floor(this.pixelX / TILE);
      this.tileY = Math.floor(this.pixelY / TILE);

      // Tunnel wrap
      if (this.tileX < 0) {
        this.tileX = COLS - 1;
        this.pixelX = this.tileX * TILE + TILE/2;
      } else if (this.tileX >= COLS) {
        this.tileX = 0;
        this.pixelX = this.tileX * TILE + TILE/2;
      }
    } else {
      this.moving = false;
    }
  }
  canMove(dir, maze) {
    const vec = DIR_VEC[dir];
    let nx = this.tileX + vec.x;
    let ny = this.tileY + vec.y;
    // Tunnel
    if (nx < 0) nx = COLS - 1;
    if (nx >= COLS) nx = 0;
    if (ny < 0 || ny >= ROWS) return false;
    const tile = maze[ny][nx];
    return tile !== T.WALL && tile !== T.GHOST_DOOR;
  }
  canMovePixel(dir, maze) {
    const vec = DIR_VEC[dir];
    const testX = this.pixelX + vec.x * this.speed;
    const testY = this.pixelY + vec.y * this.speed;
    let tx = Math.floor(testX / TILE);
    let ty = Math.floor(testY / TILE);
    if (tx < 0) return true; // tunnel
    if (tx >= COLS) return true;
    if (ty < 0 || ty >= ROWS) return false;
    const tile = maze[ty][tx];
    return tile !== T.WALL && tile !== T.GHOST_DOOR;
  }
  draw(ctx) {
    const sx = this.pixelX;
    const sy = this.pixelY + HUD_TOP;
    if (!this.alive) {
      // Death animation
      const progress = Math.min(this.deathFrame / 60, 1);
      const mouthAngle = progress * Math.PI;
      ctx.save();
      ctx.globalAlpha = 1 - progress;
      Sprites.drawPacman(ctx, sx, sy, TILE, this.direction, mouthAngle);
      ctx.restore();
      return;
    }
    // Mouth animation: 0→0.1, 1→0.25, 2→0.45, 3→0.25
    const mouthAngles = [0.1, 0.25, 0.45, 0.25];
    const mouth = this.moving ? mouthAngles[this.animFrame] : 0.1;
    Sprites.drawPacman(ctx, sx, sy, TILE, this.direction, mouth);
  }
}

// ==========================================
// GHOST CLASS
// ==========================================
class Ghost {
  constructor(name, color, scatterTarget, startTileX, startTileY) {
    this.name = name;
    this.color = color;
    this.scatterTarget = scatterTarget;
    this.startTileX = startTileX;
    this.startTileY = startTileY;
    this.dotLimit = 0; // dots eaten before this ghost leaves
    this.reset();
  }
  reset() {
    this.tileX = this.startTileX;
    this.tileY = this.startTileY;
    this.pixelX = this.tileX * TILE + TILE/2;
    this.pixelY = this.tileY * TILE + TILE/2;
    this.direction = DIR.UP;
    this.mode = GHOST_MODE.HOUSE;
    this.speed = 1.5;
    this.baseSpeed = 1.5;
    this.frightenedTimer = 0;
    this.animFrame = 0;
    this.target = { x: 0, y: 0 };
    this.leftHouse = false;
    this.recentTiles = [];
  }
  getChaseTarget(pacman, blinkyGhost) {
    switch(this.name) {
      case 'Confab': // Blinky: target Pacman directly
        return { x: pacman.tileX, y: pacman.tileY };
      case 'Drift': { // Pinky: target 4 tiles ahead
        const vec = DIR_VEC[pacman.direction] || { x: 0, y: -1 };
        return { x: pacman.tileX + vec.x * 4, y: pacman.tileY + vec.y * 4 };
      }
      case 'Bias': { // Inky: use Blinky + Pacman
        const vec = DIR_VEC[pacman.direction] || { x: 0, y: -1 };
        const ax = pacman.tileX + vec.x * 2;
        const ay = pacman.tileY + vec.y * 2;
        if (blinkyGhost) {
          return { x: ax + (ax - blinkyGhost.tileX), y: ay + (ay - blinkyGhost.tileY) };
        }
        return { x: pacman.tileX, y: pacman.tileY };
      }
      case 'Psychosis': { // Clyde: chase when far, scatter when close
        const dist = Math.sqrt((pacman.tileX - this.tileX)**2 + (pacman.tileY - this.tileY)**2);
        if (dist > 8) return { x: pacman.tileX, y: pacman.tileY };
        return this.scatterTarget;
      }
    }
    return { x: pacman.tileX, y: pacman.tileY };
  }
  update(maze, pacman, blinkyGhost, globalMode) {
    this.animFrame++;

    if (this.mode === GHOST_MODE.HOUSE) {
      // Bob up and down in house
      this.pixelY = this.startTileY * TILE + TILE/2 + Math.sin(this.animFrame * 0.1) * 3;
      return;
    }

    if (this.mode === GHOST_MODE.LEAVING) {
      // Move to exit point above ghost door
      const exitX = 10 * TILE + TILE/2;
      const exitY = 4 * TILE + TILE/2;
      const dx = exitX - this.pixelX;
      const dy = exitY - this.pixelY;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < 3) {
        this.pixelX = exitX;
        this.pixelY = exitY;
        this.tileX = Math.floor(this.pixelX / TILE);
        this.tileY = Math.floor(this.pixelY / TILE);
        this.mode = globalMode;
        this.direction = DIR.LEFT;
        this.leftHouse = true;
        return;
      }
      this.pixelX += (dx / dist) * 2;
      this.pixelY += (dy / dist) * 2;
      this.tileX = Math.floor(this.pixelX / TILE);
      this.tileY = Math.floor(this.pixelY / TILE);
      return;
    }

    if (this.mode === GHOST_MODE.FRIGHTENED) {
      this.frightenedTimer--;
      if (this.frightenedTimer <= 0) {
        this.mode = globalMode;
        this.speed = this.baseSpeed;
      }
    }

    if (this.mode === GHOST_MODE.EATEN) {
      // Head back to ghost house
      this.speed = this.baseSpeed * 2;
      this.target = { x: 10, y: 6 };
      if (Math.abs(this.tileX - 10) <= 1 && Math.abs(this.tileY - 6) <= 1) {
        this.mode = GHOST_MODE.LEAVING;
        this.speed = this.baseSpeed;
        this.pixelX = 10 * TILE + TILE/2;
        this.pixelY = 6 * TILE + TILE/2;
        this.tileX = 10;
        this.tileY = 6;
        return;
      }
    } else if (this.mode === GHOST_MODE.SCATTER) {
      this.target = this.scatterTarget;
    } else if (this.mode === GHOST_MODE.CHASE) {
      this.target = this.getChaseTarget(pacman, blinkyGhost);
    }

    // Movement at tile centers
    const atCenterX = Math.abs(this.pixelX - (this.tileX * TILE + TILE/2)) < this.speed;
    const atCenterY = Math.abs(this.pixelY - (this.tileY * TILE + TILE/2)) < this.speed;

    if (atCenterX && atCenterY) {
      this.pixelX = this.tileX * TILE + TILE/2;
      this.pixelY = this.tileY * TILE + TILE/2;

      // Choose best direction
      const bestDir = this.chooseBestDirection(maze);
      if (bestDir !== DIR.NONE) {
        this.direction = bestDir;
      }
    }

    // Move
    const vec = DIR_VEC[this.direction];
    if (vec) {
      this.pixelX += vec.x * this.speed;
      this.pixelY += vec.y * this.speed;
      this.tileX = Math.floor(this.pixelX / TILE);
      this.tileY = Math.floor(this.pixelY / TILE);

      // Tunnel wrap
      if (this.tileX < 0) {
        this.tileX = COLS - 1;
        this.pixelX = this.tileX * TILE + TILE/2;
      } else if (this.tileX >= COLS) {
        this.tileX = 0;
        this.pixelX = this.tileX * TILE + TILE/2;
      }
    }
  }
  chooseBestDirection(maze) {
    const opposite = OPPOSITE[this.direction];
    const dirs = [DIR.UP, DIR.LEFT, DIR.DOWN, DIR.RIGHT];

    // Gather all valid directions
    const validDirs = [];
    for (const dir of dirs) {
      if (dir === opposite) continue;
      const vec = DIR_VEC[dir];
      let nx = this.tileX + vec.x;
      let ny = this.tileY + vec.y;
      if (nx < 0) nx = COLS - 1;
      if (nx >= COLS) nx = 0;
      if (ny < 0 || ny >= ROWS) continue;
      const tile = maze[ny][nx];
      if (tile === T.WALL) continue;
      if (tile === T.GHOST_DOOR && this.mode !== GHOST_MODE.EATEN) continue;
      validDirs.push({ dir, nx, ny });
    }

    if (validDirs.length === 0) return DIR.NONE;

    // Frightened: fully random
    if (this.mode === GHOST_MODE.FRIGHTENED) {
      return validDirs[Math.floor(Math.random() * validDirs.length)].dir;
    }

    // Loop detection: track recent tiles and force random if looping
    if (!this.recentTiles) this.recentTiles = [];
    const posKey = this.tileX + ',' + this.tileY;
    this.recentTiles.push(posKey);
    if (this.recentTiles.length > 16) this.recentTiles.shift();

    // Count how many times we've been at this tile recently
    const visitCount = this.recentTiles.filter(p => p === posKey).length;
    const isLooping = visitCount >= 3;

    // If looping or random jitter (25% chance), pick a random valid direction
    // Prefer directions we haven't visited recently
    if (isLooping || (validDirs.length > 1 && Math.random() < 0.25)) {
      // Try to pick an unvisited direction first
      const unvisited = validDirs.filter(d => {
        const key = d.nx + ',' + d.ny;
        return !this.recentTiles.includes(key);
      });
      if (unvisited.length > 0) {
        return unvisited[Math.floor(Math.random() * unvisited.length)].dir;
      }
      // Fallback: random from all valid
      return validDirs[Math.floor(Math.random() * validDirs.length)].dir;
    }

    // Normal targeting: pick direction closest to target
    let bestDist = Infinity;
    let bestDir = validDirs[0].dir;
    for (const { dir, nx, ny } of validDirs) {
      const dist = (nx - this.target.x)**2 + (ny - this.target.y)**2;
      if (dist < bestDist) {
        bestDist = dist;
        bestDir = dir;
      }
    }
    return bestDir;
  }
  setFrightened(duration) {
    if (this.mode === GHOST_MODE.HOUSE || this.mode === GHOST_MODE.LEAVING || this.mode === GHOST_MODE.EATEN) return;
    this.mode = GHOST_MODE.FRIGHTENED;
    this.frightenedTimer = duration || 360;
    this.speed = this.baseSpeed * 0.5;
    // Reverse direction
    this.direction = OPPOSITE[this.direction] || this.direction;
  }
  draw(ctx) {
    const sx = this.pixelX;
    const sy = this.pixelY + HUD_TOP;
    Sprites.drawGhost(ctx, sx, sy, TILE, this.color, this.mode, this.direction, this.animFrame);
  }
}

// ==========================================
// GAME STATE
// ==========================================
class Game {
  constructor() {
    this.state = STATE.LOGO;
    this.logoTimer = 300; // 5 seconds at 60fps
    this.score = 0;
    this.highScore = parseInt(localStorage.getItem('pacmanNTC_high') || '0');
    this.lives = 3;
    this.level = 1;
    this.levelName = LEVEL_CONFIGS[0].name;
    this.maze = null;
    this.pacman = new Pacman();
    this.ghosts = [];
    this.frame = 0;
    this.dotsTotal = 0;
    this.dotsEaten = 0;
    this.ghostsEatenCombo = 0;
    this.modeTimer = 0;
    this.globalMode = GHOST_MODE.SCATTER;
    this.modeWave = 0;
    this.readyTimer = 0;
    this.deathTimer = 0;
    this.levelCompleteTimer = 0;
    this.levelSplashTimer = 0;
    this.frightenedDuration = 420;
    this.bonusItem = null;
    this.bonusTimer = 0;
    this.scorePopups = [];
    this.creditsScrollY = 0;
    this.fadeAlpha = 0;
    this.fadeDir = 0;
    this.fadeCallback = null;

    // Win screen animation
    this.winTweetIndex = 0;
    this.winAnimTimer = 0;

    this.setupClickHandler();
  }

  setupClickHandler() {
    input.onClickOrTap((x, y) => {
      sound.init();
      switch (this.state) {
        case STATE.SPLASH:
          this.fadeTo(STATE.EXPLAINER);
          break;
        case STATE.EXPLAINER:
          // Two button zones: play (y < 290) vs skip to credits (y >= 290)
          if (y >= 290) {
            this.fadeTo(STATE.WIN);
            this.winTweetIndex = 0;
            this.winAnimTimer = 0;
          } else {
            this.level = 1;
            this.levelSplashTimer = 180;
            this.fadeTo(STATE.LEVEL_SPLASH);
          }
          break;
        case STATE.LEVEL_SPLASH:
          // Tap to skip level splash
          this.startLevel();
          break;
        case STATE.GAME_OVER:
          this.fadeTo(STATE.SCORE_SCREEN);
          break;
        case STATE.WIN:
          this.fadeTo(STATE.SCORE_SCREEN);
          break;
        case STATE.SCORE_SCREEN:
          this.fadeTo(STATE.CREDITS);
          this.creditsScrollY = CANVAS_H;
          break;
        case STATE.CREDITS:
          // Skip credits
          this.fireworks = [];
          this.fadeTo(STATE.END);
          break;
        case STATE.END:
          // Play again
          this.score = 0;
          this.lives = 3;
          this.level = 1;
          this.fadeTo(STATE.SPLASH);
          break;
      }
    });
  }

  fadeTo(newState) {
    if (this.fadeDir !== 0) return;
    this.fadeDir = 1;
    this.fadeAlpha = 0;
    this.fadeCallback = () => {
      this.state = newState;
      this.fadeDir = -1;
    };
  }

  startLevel() {
    const config = LEVEL_CONFIGS[this.level - 1];
    this.levelName = config.name;
    this.maze = parseMaze(config.maze);
    this.pacman.reset();
    this.dotsTotal = 0;
    this.dotsEaten = 0;
    this.ghostsEatenCombo = 0;
    this.modeWave = 0;
    this.modeTimer = 0;
    this.globalMode = GHOST_MODE.SCATTER;
    this.bonusItem = null;
    this.bonusTimer = 0;
    this.scorePopups = [];

    // Count dots
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (this.maze[r][c] === T.DOT || this.maze[r][c] === T.POWER) this.dotsTotal++;
      }
    }

    // Create ghosts
    this.ghosts = [
      new Ghost('Confab', COLORS.ghostPink, { x: 19, y: 0 }, 10, 6),
      new Ghost('Drift', COLORS.ghostPeach, { x: 1, y: 0 }, 11, 6),
      new Ghost('Bias', COLORS.ghostMint, { x: 20, y: 16 }, 9, 6),
      new Ghost('Psychosis', COLORS.ghostYellow, { x: 0, y: 16 }, 12, 6),
    ];

    // Confab starts outside immediately
    this.ghosts[0].mode = GHOST_MODE.LEAVING;
    // Others leave after dot counts (per-level config)
    this.ghosts[1].dotLimit = config.ghostDotLimits[1];
    this.ghosts[1].mode = GHOST_MODE.HOUSE;
    this.ghosts[2].dotLimit = config.ghostDotLimits[2];
    this.ghosts[2].mode = GHOST_MODE.HOUSE;
    this.ghosts[3].dotLimit = config.ghostDotLimits[3];
    this.ghosts[3].mode = GHOST_MODE.HOUSE;

    // Difficulty scaling from level config
    this.ghosts.forEach(g => {
      g.baseSpeed = 1.5 * config.speedMultiplier;
      g.speed = g.baseSpeed;
    });

    this.frightenedDuration = config.frightenedDuration;

    this.readyTimer = 120; // 2 seconds
    this.state = STATE.READY;
    sound.play('start');
  }

  resetAfterDeath() {
    this.pacman.reset();
    this.ghosts.forEach(g => g.reset());
    this.ghosts[0].mode = GHOST_MODE.LEAVING;
    this.globalMode = GHOST_MODE.SCATTER;
    this.modeWave = 0;
    this.modeTimer = 0;
    this.readyTimer = 90;
    this.state = STATE.READY;
  }

  update() {
    this.frame++;

    // Handle fade
    if (this.fadeDir !== 0) {
      this.fadeAlpha += this.fadeDir * 0.05;
      if (this.fadeAlpha >= 1 && this.fadeDir === 1) {
        this.fadeAlpha = 1;
        if (this.fadeCallback) {
          this.fadeCallback();
          this.fadeCallback = null;
        }
      }
      if (this.fadeAlpha <= 0 && this.fadeDir === -1) {
        this.fadeAlpha = 0;
        this.fadeDir = 0;
      }
      return;
    }

    switch (this.state) {
      case STATE.LOGO:
        this.logoTimer--;
        if (this.logoTimer <= 0) {
          this.state = STATE.SPLASH;
        }
        break;

      case STATE.READY:
        this.readyTimer--;
        if (this.readyTimer <= 0) {
          this.state = STATE.PLAYING;
        }
        break;

      case STATE.PLAYING:
        this.updatePlaying();
        break;

      case STATE.PACMAN_DEATH:
        this.deathTimer++;
        this.pacman.update(this.maze);
        if (this.deathTimer > 90) {
          if (this.lives > 0) {
            this.resetAfterDeath();
          } else {
            this.state = STATE.GAME_OVER;
          }
        }
        break;

      case STATE.LEVEL_COMPLETE:
        this.levelCompleteTimer++;
        if (this.levelCompleteTimer > 120) {
          if (this.level < 4) {
            this.level++;
            this.levelSplashTimer = 180;
            this.fadeTo(STATE.LEVEL_SPLASH);
          } else {
            this.fadeTo(STATE.WIN);
            this.winTweetIndex = 0;
            this.winAnimTimer = 0;
          }
        }
        break;

      case STATE.LEVEL_SPLASH:
        this.levelSplashTimer--;
        if (this.levelSplashTimer <= 0) {
          this.startLevel();
        }
        break;

      case STATE.WIN:
        this.winAnimTimer++;
        if (this.winAnimTimer % 60 === 0 && this.winTweetIndex < 4) {
          this.winTweetIndex++;
        }
        break;

      case STATE.CREDITS:
        this.creditsScrollY -= 1;
        if (this.creditsScrollY < -1200) {
          this.fireworks = [];
          this.fadeTo(STATE.END);
        }
        break;
    }
  }

  updatePlaying() {
    // Update mode timer (scatter/chase waves)
    this.modeTimer++;
    const scatterBase = Math.max(120, 420 - (this.level - 1) * 100);
    const scatterLate = Math.max(60, 300 - (this.level - 1) * 80);
    const waves = [
      { mode: GHOST_MODE.SCATTER, duration: scatterBase },
      { mode: GHOST_MODE.CHASE, duration: 1200 },
      { mode: GHOST_MODE.SCATTER, duration: scatterBase },
      { mode: GHOST_MODE.CHASE, duration: 1200 },
      { mode: GHOST_MODE.SCATTER, duration: scatterLate },
      { mode: GHOST_MODE.CHASE, duration: 1200 },
      { mode: GHOST_MODE.SCATTER, duration: scatterLate },
      { mode: GHOST_MODE.CHASE, duration: 99999 },
    ];
    if (this.modeWave < waves.length && this.modeTimer >= waves[this.modeWave].duration) {
      this.modeTimer = 0;
      this.globalMode = waves[this.modeWave].mode;
      this.modeWave++;
      // Update non-frightened ghosts
      this.ghosts.forEach(g => {
        if (g.mode === GHOST_MODE.SCATTER || g.mode === GHOST_MODE.CHASE) {
          g.mode = this.globalMode;
          g.direction = OPPOSITE[g.direction] || g.direction;
        }
      });
    }

    // Release ghosts from house based on dots eaten
    this.ghosts.forEach(g => {
      if (g.mode === GHOST_MODE.HOUSE && this.dotsEaten >= g.dotLimit) {
        g.mode = GHOST_MODE.LEAVING;
      }
    });

    // Update pacman
    this.pacman.update(this.maze);

    // Check dot collection
    const pt = this.maze[this.pacman.tileY] && this.maze[this.pacman.tileY][this.pacman.tileX];
    if (pt === T.DOT) {
      this.maze[this.pacman.tileY][this.pacman.tileX] = T.EMPTY;
      this.score += 10;
      this.dotsEaten++;
      if (this.frame % 2 === 0) sound.play('chomp');
    } else if (pt === T.POWER) {
      this.maze[this.pacman.tileY][this.pacman.tileX] = T.EMPTY;
      this.score += 50;
      this.dotsEaten++;
      this.ghostsEatenCombo = 0;
      this.ghosts.forEach(g => g.setFrightened(this.frightenedDuration));
      sound.play('power');
    }

    // Bonus item
    const bonusTrigger1 = Math.floor(this.dotsTotal * 0.4);
    const bonusTrigger2 = Math.floor(this.dotsTotal * 0.8);
    if (!this.bonusItem && (this.dotsEaten === bonusTrigger1 || this.dotsEaten === bonusTrigger2)) {
      this.bonusItem = { x: 10, y: 9, timer: 540 }; // 9 seconds
    }
    if (this.bonusItem) {
      this.bonusItem.timer--;
      if (this.bonusItem.timer <= 0) this.bonusItem = null;
      else if (this.pacman.tileX === this.bonusItem.x && this.pacman.tileY === this.bonusItem.y) {
        this.score += 100;
        this.addScorePopup(this.bonusItem.x * TILE + TILE/2, this.bonusItem.y * TILE + TILE/2 + HUD_TOP, 100);
        this.bonusItem = null;
        sound.play('eatghost');
      }
    }

    // Update ghosts
    const blinky = this.ghosts[0];
    this.ghosts.forEach(g => g.update(this.maze, this.pacman, blinky, this.globalMode));

    // Check ghost collisions
    for (const g of this.ghosts) {
      if (g.mode === GHOST_MODE.HOUSE || g.mode === GHOST_MODE.LEAVING || g.mode === GHOST_MODE.EATEN) continue;
      const dist = Math.sqrt((this.pacman.pixelX - g.pixelX)**2 + (this.pacman.pixelY - g.pixelY)**2);
      if (dist < TILE * 0.8) {
        if (g.mode === GHOST_MODE.FRIGHTENED) {
          // Eat ghost
          g.mode = GHOST_MODE.EATEN;
          this.ghostsEatenCombo++;
          const pts = 200 * Math.pow(2, this.ghostsEatenCombo - 1);
          this.score += pts;
          this.addScorePopup(g.pixelX, g.pixelY + HUD_TOP, pts);
          sound.play('eatghost');
        } else {
          // Pacman dies
          this.pacman.alive = false;
          this.pacman.deathFrame = 0;
          this.lives--;
          this.deathTimer = 0;
          this.state = STATE.PACMAN_DEATH;
          sound.play('death');
          break;
        }
      }
    }

    // Check level complete
    if (this.dotsEaten >= this.dotsTotal) {
      this.state = STATE.LEVEL_COMPLETE;
      this.levelCompleteTimer = 0;
      sound.play('levelcomplete');
    }

    // Update high score
    if (this.score > this.highScore) {
      this.highScore = this.score;
      localStorage.setItem('pacmanNTC_high', String(this.highScore));
    }

    // Update score popups
    this.scorePopups = this.scorePopups.filter(p => {
      p.y -= 0.5;
      p.timer--;
      return p.timer > 0;
    });
  }

  addScorePopup(x, y, points) {
    this.scorePopups.push({ x, y, points, timer: 60 });
  }

  // ==========================================
  // RENDERING
  // ==========================================
  render() {
    ctx.fillStyle = COLORS.background;
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

    switch (this.state) {
      case STATE.LOGO: this.renderLogo(); break;
      case STATE.SPLASH: this.renderSplash(); break;
      case STATE.EXPLAINER: this.renderExplainer(); break;
      case STATE.LEVEL_SPLASH: this.renderLevelSplash(); break;
      case STATE.READY:
      case STATE.PLAYING:
      case STATE.PACMAN_DEATH:
      case STATE.LEVEL_COMPLETE:
        this.renderGameplay();
        break;
      case STATE.GAME_OVER: this.renderGameOver(); break;
      case STATE.SCORE_SCREEN: this.renderScoreScreen(); break;
      case STATE.WIN: this.renderWin(); break;
      case STATE.CREDITS: this.renderCredits(); break;
      case STATE.END: this.renderEnd(); break;
    }

    // Fade overlay
    if (this.fadeAlpha > 0) {
      ctx.fillStyle = `rgba(0,0,0,${this.fadeAlpha})`;
      ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
    }
  }

  renderLogo() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
    if (logoImg.complete && logoImg.naturalWidth > 0) {
      // Scale image to fit canvas while maintaining aspect ratio
      const imgAspect = logoImg.naturalWidth / logoImg.naturalHeight;
      const canvasAspect = CANVAS_W / CANVAS_H;
      let drawW, drawH;
      if (imgAspect > canvasAspect) {
        drawW = CANVAS_W * 0.8;
        drawH = drawW / imgAspect;
      } else {
        drawH = CANVAS_H * 0.7;
        drawW = drawH * imgAspect;
      }
      const drawX = (CANVAS_W - drawW) / 2;
      const drawY = (CANVAS_H - drawH) / 2;
      // Smooth fade: full opacity for first 2s (120 frames), then fade over remaining 3s (180 frames)
      const fadeStart = 180; // start fading when timer hits this
      if (this.logoTimer < fadeStart) {
        ctx.globalAlpha = this.logoTimer / fadeStart;
      }
      ctx.drawImage(logoImg, drawX, drawY, drawW, drawH);
      ctx.globalAlpha = 1;
    }
  }

  renderSplash() {
    const cx = CANVAS_W / 2;
    const cy = CANVAS_H / 2;
    const t = this.frame;

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // === Animated starfield background ===
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
    for (let i = 0; i < 40; i++) {
      const sx = ((i * 137 + t * (0.3 + (i % 3) * 0.2)) % CANVAS_W);
      const sy = ((i * 97 + t * (0.1 + (i % 4) * 0.05)) % CANVAS_H);
      const twinkle = 0.3 + 0.7 * Math.abs(Math.sin(t * 0.03 + i));
      ctx.globalAlpha = twinkle * 0.6;
      const starSize = (i % 3 === 0) ? 2 : 1;
      ctx.fillStyle = (i % 5 === 0) ? '#00FFFF' : (i % 7 === 0) ? '#FFD700' : '#FFF';
      ctx.fillRect(Math.floor(sx), Math.floor(sy), starSize, starSize);
    }
    ctx.globalAlpha = 1;

    // === Decorative top border — pixel dot pattern ===
    for (let i = 0; i < CANVAS_W; i += 8) {
      const dotAlpha = 0.3 + 0.2 * Math.sin(t * 0.05 + i * 0.1);
      ctx.globalAlpha = dotAlpha;
      ctx.fillStyle = '#00FFFF';
      ctx.fillRect(i + 3, 6, 2, 2);
      ctx.fillRect(i + 3, CANVAS_H - 8, 2, 2);
    }
    ctx.globalAlpha = 1;

    // === "PACMAN" title with glow effect ===
    const glowIntensity = 0.5 + 0.5 * Math.sin(t * 0.04);
    ctx.save();
    ctx.shadowColor = '#00FFFF';
    ctx.shadowBlur = 8 + glowIntensity * 8;
    ctx.fillStyle = '#00FFFF';
    ctx.font = '14px "Press Start 2P"';
    ctx.fillText('PACMAN', cx, 38);
    ctx.restore();

    // === Decorative line under title ===
    const lineW = 120;
    const lineGrad = ctx.createLinearGradient(cx - lineW/2, 0, cx + lineW/2, 0);
    lineGrad.addColorStop(0, 'rgba(0,255,255,0)');
    lineGrad.addColorStop(0.3, 'rgba(0,255,255,0.8)');
    lineGrad.addColorStop(0.5, 'rgba(255,215,0,1)');
    lineGrad.addColorStop(0.7, 'rgba(0,255,255,0.8)');
    lineGrad.addColorStop(1, 'rgba(0,255,255,0)');
    ctx.fillStyle = lineGrad;
    ctx.fillRect(cx - lineW/2, 52, lineW, 2);

    // === Subtitle: Three lines ===
    ctx.fillStyle = '#FFFFFF';
    ctx.font = '7px "Press Start 2P"';
    ctx.fillText('Nine Treasures Creamery', cx, 74);

    // "x" in gold
    ctx.fillStyle = '#FFD700';
    ctx.font = '9px "Press Start 2P"';
    ctx.fillText('x', cx, 94);

    // Edition name with slight color shift
    ctx.fillStyle = '#FF69B4';
    ctx.font = '6px "Press Start 2P"';
    ctx.fillText('AI-Pilled Asians', cx, 114);
    ctx.fillText('in Tech Edition', cx, 130);

    // === Central Pacman — animated chomping + moving dots ===
    const mouthAnim = 0.15 + 0.35 * Math.abs(Math.sin(t * 0.12));
    Sprites.drawPacman(ctx, cx, cy + 10, 44, DIR.RIGHT, mouthAnim);

    // Dot trail being eaten by pacman
    for (let d = 0; d < 5; d++) {
      const dotX = cx + 34 + d * 14;
      if (dotX < CANVAS_W - 20) {
        const eaten = ((t * 0.06) % 6) > d;
        if (!eaten) {
          ctx.globalAlpha = 0.8;
          ctx.fillStyle = '#FFF';
          ctx.beginPath();
          ctx.arc(dotX, cy + 10, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
    ctx.globalAlpha = 1;

    // === Ghosts in a row — with subtle bob animation ===
    const ghostColors = [COLORS.ghostPink, COLORS.ghostPeach, COLORS.ghostMint, COLORS.ghostYellow];
    ghostColors.forEach((c, i) => {
      const bobY = Math.sin(t * 0.06 + i * 1.2) * 3;
      const gx = cx - 66 + i * 44;
      const gy = cy + 62 + bobY;
      Sprites.drawGhost(ctx, gx, gy, 18, c, GHOST_MODE.CHASE, DIR.LEFT, t + i * 10);
    });

    // === Decorative sparkles flanking the scene ===
    Sprites.drawSparkle(ctx, 24, cy - 10, 12, t);
    Sprites.drawSparkle(ctx, CANVAS_W - 24, cy - 10, 12, t + 30);
    Sprites.drawSparkle(ctx, 40, cy + 50, 8, t + 60);
    Sprites.drawSparkle(ctx, CANVAS_W - 40, cy + 50, 8, t + 90);

    // === "TAP TO START" with strong pulse ===
    const pulse = 1 + 0.08 * Math.sin(t * 0.1);
    const tapAlpha = 0.6 + 0.4 * Math.sin(t * 0.08);
    ctx.save();
    ctx.globalAlpha = tapAlpha;
    ctx.shadowColor = '#00FFFF';
    ctx.shadowBlur = 6;
    ctx.fillStyle = '#00FFFF';
    ctx.font = `${Math.round(10 * pulse)}px "Press Start 2P"`;
    ctx.fillText('TAP TO START', cx, CANVAS_H - 30);
    ctx.restore();

    // === Bottom decorative border ===
    const bottomLineGrad = ctx.createLinearGradient(cx - lineW/2, 0, cx + lineW/2, 0);
    bottomLineGrad.addColorStop(0, 'rgba(255,105,180,0)');
    bottomLineGrad.addColorStop(0.5, 'rgba(255,105,180,0.6)');
    bottomLineGrad.addColorStop(1, 'rgba(255,105,180,0)');
    ctx.fillStyle = bottomLineGrad;
    ctx.fillRect(cx - lineW/2, CANVAS_H - 14, lineW, 1);
  }

  renderExplainer() {
    const cx = CANVAS_W / 2;
    const cy = CANVAS_H / 2;
    const t = this.frame;

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // === Animated starfield background ===
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
    for (let i = 0; i < 40; i++) {
      const sx = ((i * 137 + t * (0.3 + (i % 3) * 0.2)) % CANVAS_W);
      const sy = ((i * 97 + t * (0.1 + (i % 4) * 0.05)) % CANVAS_H);
      const twinkle = 0.3 + 0.7 * Math.abs(Math.sin(t * 0.03 + i));
      ctx.globalAlpha = twinkle * 0.6;
      const starSize = (i % 3 === 0) ? 2 : 1;
      ctx.fillStyle = (i % 5 === 0) ? '#00FFFF' : (i % 7 === 0) ? '#FFD700' : '#FFF';
      ctx.fillRect(Math.floor(sx), Math.floor(sy), starSize, starSize);
    }
    ctx.globalAlpha = 1;

    // === Decorative dot borders ===
    for (let i = 0; i < CANVAS_W; i += 8) {
      const dotAlpha = 0.3 + 0.2 * Math.sin(t * 0.05 + i * 0.1);
      ctx.globalAlpha = dotAlpha;
      ctx.fillStyle = '#00FFFF';
      ctx.fillRect(i + 3, 6, 2, 2);
      ctx.fillRect(i + 3, CANVAS_H - 8, 2, 2);
    }
    ctx.globalAlpha = 1;

    // === "HOW TO PLAY" title with glow ===
    const glowIntensity = 0.5 + 0.5 * Math.sin(t * 0.04);
    ctx.save();
    ctx.shadowColor = '#00FFFF';
    ctx.shadowBlur = 8 + glowIntensity * 8;
    ctx.fillStyle = '#00FFFF';
    ctx.font = '11px "Press Start 2P"';
    ctx.fillText('HOW TO PLAY', cx, 36);
    ctx.restore();

    // === Gradient divider ===
    const lineW = 140;
    const lineGrad = ctx.createLinearGradient(cx - lineW/2, 0, cx + lineW/2, 0);
    lineGrad.addColorStop(0, 'rgba(0,255,255,0)');
    lineGrad.addColorStop(0.3, 'rgba(0,255,255,0.8)');
    lineGrad.addColorStop(0.5, 'rgba(255,215,0,1)');
    lineGrad.addColorStop(0.7, 'rgba(0,255,255,0.8)');
    lineGrad.addColorStop(1, 'rgba(0,255,255,0)');
    ctx.fillStyle = lineGrad;
    ctx.fillRect(cx - lineW/2, 50, lineW, 2);

    // === Instructions ===
    ctx.fillStyle = '#FFFFFF';
    ctx.font = '6px "Press Start 2P"';
    ctx.fillText('Eat all tokens to clear', cx, 72);
    ctx.fillText('each level.', cx, 88);

    // === AI Pills row ===
    Sprites.drawSparkle(ctx, cx - 60, 118, 18, t);
    ctx.fillStyle = '#FFD700';
    ctx.font = '7px "Press Start 2P"';
    ctx.textAlign = 'left';
    ctx.fillText('AI Pills', cx - 36, 118);

    // === Hallucination row ===
    ctx.textAlign = 'center';
    Sprites.drawGhost(ctx, cx - 60, 152, 16, COLORS.ghostPink, GHOST_MODE.CHASE, DIR.LEFT, t);
    ctx.fillStyle = '#FF69B4';
    ctx.font = '7px "Press Start 2P"';
    ctx.textAlign = 'left';
    ctx.fillText('Hallucination', cx - 36, 152);

    // === Controls — two lines ===
    ctx.textAlign = 'center';
    ctx.fillStyle = '#888';
    ctx.font = '5px "Press Start 2P"';
    ctx.fillText('Mobile: Swipe', cx, 192);
    ctx.fillText('Desktop: Arrow Keys', cx, 208);

    // === Decorative divider before buttons ===
    const divGrad = ctx.createLinearGradient(cx - lineW/2, 0, cx + lineW/2, 0);
    divGrad.addColorStop(0, 'rgba(255,105,180,0)');
    divGrad.addColorStop(0.5, 'rgba(255,105,180,0.5)');
    divGrad.addColorStop(1, 'rgba(255,105,180,0)');
    ctx.fillStyle = divGrad;
    ctx.fillRect(cx - lineW/2, 232, lineW, 1);

    // === Decorative sparkles ===
    Sprites.drawSparkle(ctx, 20, 120, 10, t + 20);
    Sprites.drawSparkle(ctx, CANVAS_W - 20, 120, 10, t + 50);
    Sprites.drawSparkle(ctx, 30, 200, 8, t + 80);
    Sprites.drawSparkle(ctx, CANVAS_W - 30, 200, 8, t + 110);

    // === "TAP TO PLAY" button — cyan with glow ===
    const pulse1 = 1 + 0.06 * Math.sin(t * 0.1);
    ctx.save();
    ctx.globalAlpha = 0.7 + 0.3 * Math.sin(t * 0.08);
    ctx.shadowColor = '#00FFFF';
    ctx.shadowBlur = 8;
    ctx.fillStyle = '#00FFFF';
    ctx.font = `${Math.round(9 * pulse1)}px "Press Start 2P"`;
    ctx.textAlign = 'center';
    ctx.fillText('TAP TO PLAY', cx, 268);
    ctx.restore();

    // === "SKIP TO CREDITS" button — pink with glow ===
    const pulse2 = 1 + 0.06 * Math.sin(t * 0.1 + 1.5);
    ctx.save();
    ctx.globalAlpha = 0.7 + 0.3 * Math.sin(t * 0.08 + 1.5);
    ctx.shadowColor = '#FF69B4';
    ctx.shadowBlur = 8;
    ctx.fillStyle = '#FF69B4';
    ctx.font = `${Math.round(9 * pulse2)}px "Press Start 2P"`;
    ctx.textAlign = 'center';
    ctx.fillText('SKIP TO CREDITS', cx, 310);
    ctx.restore();

    // === Bottom decorative border ===
    const bottomGrad = ctx.createLinearGradient(cx - lineW/2, 0, cx + lineW/2, 0);
    bottomGrad.addColorStop(0, 'rgba(0,255,255,0)');
    bottomGrad.addColorStop(0.5, 'rgba(0,255,255,0.4)');
    bottomGrad.addColorStop(1, 'rgba(0,255,255,0)');
    ctx.fillStyle = bottomGrad;
    ctx.fillRect(cx - lineW/2, CANVAS_H - 14, lineW, 1);
  }

  renderLevelSplash() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

    const img = levelImages[this.level - 1];
    if (img.complete && img.naturalWidth > 0) {
      const imgAspect = img.naturalWidth / img.naturalHeight;
      const canvasAspect = CANVAS_W / CANVAS_H;
      let drawW, drawH;
      if (imgAspect > canvasAspect) {
        drawW = CANVAS_W * 0.85;
        drawH = drawW / imgAspect;
      } else {
        drawH = CANVAS_H * 0.75;
        drawW = drawH * imgAspect;
      }
      const drawX = (CANVAS_W - drawW) / 2;
      const drawY = (CANVAS_H - drawH) / 2;

      // Fade out in last 1 second (60 frames)
      const fadeStart = 60;
      if (this.levelSplashTimer < fadeStart) {
        ctx.globalAlpha = this.levelSplashTimer / fadeStart;
      }
      ctx.drawImage(img, drawX, drawY, drawW, drawH);
      ctx.globalAlpha = 1;
    }
  }

  renderGameplay() {
    // Draw maze
    drawMaze(ctx, this.maze, this.frame, LEVEL_CONFIGS[this.level - 1].wallColor);

    // Draw bonus item
    if (this.bonusItem) {
      Sprites.drawIceCream(
        ctx,
        this.bonusItem.x * TILE + TILE/2,
        this.bonusItem.y * TILE + TILE/2 + HUD_TOP,
        TILE, LEVEL_CONFIGS[this.level - 1].scoopColor
      );
    }

    // Draw pacman
    this.pacman.draw(ctx);

    // Draw ghosts
    this.ghosts.forEach(g => g.draw(ctx));

    // Score popups
    this.scorePopups.forEach(p => {
      ctx.save();
      ctx.globalAlpha = p.timer / 60;
      ctx.fillStyle = COLORS.textCyan;
      ctx.font = '7px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.fillText(String(p.points), p.x, p.y);
      ctx.restore();
    });

    // HUD
    this.renderHUD();

    // Ready overlay
    if (this.state === STATE.READY) {
      ctx.fillStyle = '#FFD700';
      ctx.font = '12px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.fillText('READY!', CANVAS_W / 2, CANVAS_H / 2 + 20);
      ctx.fillStyle = COLORS.text;
      ctx.font = '8px "Press Start 2P"';
      ctx.fillText(this.levelName, CANVAS_W / 2, CANVAS_H / 2 + 50);
    }

    // Level complete flash
    if (this.state === STATE.LEVEL_COMPLETE) {
      if (Math.floor(this.levelCompleteTimer / 15) % 2 === 0) {
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
      }
    }
  }

  renderHUD() {
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillStyle = COLORS.text;
    ctx.font = '8px "Press Start 2P"';

    // Score
    ctx.fillText('SCORE', 8, 6);
    ctx.fillStyle = COLORS.textCyan;
    ctx.fillText(String(this.score).padStart(6, '0'), 8, 20);

    // High score
    ctx.fillStyle = COLORS.text;
    ctx.textAlign = 'center';
    ctx.fillText('HIGH', CANVAS_W / 2, 6);
    ctx.fillStyle = COLORS.textCyan;
    ctx.fillText(String(this.highScore).padStart(6, '0'), CANVAS_W / 2, 20);

    // Level
    ctx.fillStyle = COLORS.text;
    ctx.textAlign = 'right';
    ctx.fillText('LVL ' + this.level, CANVAS_W - 8, 6);
    ctx.fillStyle = '#DDD';
    ctx.font = '6px "Press Start 2P"';
    ctx.fillText(this.levelName, CANVAS_W - 8, 22);

    // Lives (bottom)
    for (let i = 0; i < this.lives; i++) {
      Sprites.drawPacman(ctx, 20 + i * 24, CANVAS_H - 20, 14, DIR.RIGHT, 0.3);
    }

    // Mute button
    ctx.textAlign = 'right';
    ctx.fillStyle = '#666';
    ctx.font = '7px "Press Start 2P"';
    ctx.fillText(sound.muted ? 'MUTE' : 'SND', CANVAS_W - 8, CANVAS_H - 24);
  }

  renderGameOver() {
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#FF0000';
    ctx.font = '16px "Press Start 2P"';
    ctx.fillText('GAME OVER', CANVAS_W / 2, CANVAS_H / 2 - 20);

    ctx.fillStyle = COLORS.text;
    ctx.font = '8px "Press Start 2P"';
    ctx.fillText('SCORE: ' + this.score, CANVAS_W / 2, CANVAS_H / 2 + 30);

    ctx.fillStyle = COLORS.textCyan;
    ctx.font = '8px "Press Start 2P"';
    const pulse = 0.5 + 0.5 * Math.sin(this.frame * 0.08);
    ctx.globalAlpha = pulse;
    ctx.fillText('TAP TO CONTINUE', CANVAS_W / 2, CANVAS_H / 2 + 80);
    ctx.globalAlpha = 1;
  }

  renderWin() {
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Dark "twitter" background
    ctx.fillStyle = '#15202B';
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

    // Header
    ctx.fillStyle = '#1DA1F2';
    ctx.font = '8px "Press Start 2P"';
    ctx.fillText('BREAKING NEWS', CANVAS_W / 2, 40);

    // Sam Altman tweet
    if (this.winTweetIndex >= 0) {
      this.drawTweet(ctx, 40, 70, '@sama', 'Sam Altman', 'agi has been achieved', '❤️', '#FF6B6B');
    }

    // Reply tweets
    const replies = [
      { handle: '@tszzl', name: 'roon', text: '❤️' },
      { handle: '@gaborcselle', name: 'Gabor Cselle', text: '❤️' },
      { handle: '@OfficialLoganK', name: 'Logan K', text: '❤️' },
    ];
    replies.forEach((r, i) => {
      if (this.winTweetIndex > i) {
        this.drawTweet(ctx, 40, 200 + i * 100, r.handle, r.name, r.text, '', '#FF6B6B');
      }
    });

    // Continue prompt
    if (this.winTweetIndex >= 4) {
      ctx.fillStyle = COLORS.textCyan;
      ctx.font = '8px "Press Start 2P"';
      const pulse = 0.5 + 0.5 * Math.sin(this.frame * 0.08);
      ctx.globalAlpha = pulse;
      ctx.fillText('TAP TO CONTINUE', CANVAS_W / 2, CANVAS_H - 40);
      ctx.globalAlpha = 1;
    }
  }

  drawTweet(ctx, x, y, handle, name, text, emoji, emojiColor) {
    // Card background
    ctx.fillStyle = '#192734';
    const cardW = CANVAS_W - 80;
    ctx.fillRect(x, y, cardW, 80);

    // Profile pic placeholder
    ctx.fillStyle = '#AAA';
    ctx.beginPath();
    ctx.arc(x + 24, y + 24, 14, 0, Math.PI * 2);
    ctx.fill();

    // Name and handle
    ctx.textAlign = 'left';
    ctx.fillStyle = '#FFF';
    ctx.font = '7px "Press Start 2P"';
    ctx.fillText(name, x + 46, y + 16);
    ctx.fillStyle = '#8899A6';
    ctx.font = '6px "Press Start 2P"';
    ctx.fillText(handle, x + 46, y + 30);

    // Tweet text
    ctx.fillStyle = '#FFF';
    ctx.font = '7px "Press Start 2P"';
    ctx.fillText(text, x + 20, y + 58);

    // Emoji
    if (emoji) {
      ctx.fillStyle = emojiColor || '#FFF';
      ctx.font = '10px "Press Start 2P"';
      ctx.textAlign = 'right';
      ctx.fillText(emoji, x + cardW - 10, y + 58);
    }
  }

  renderCredits() {
    const cx = CANVAS_W / 2;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    const y = this.creditsScrollY;

    // === HALLUCINATIONS section ===
    ctx.fillStyle = COLORS.text;
    ctx.font = '12px "Press Start 2P"';
    ctx.fillText('HALLUCINATIONS', cx, y);

    const ghostData = [
      { name: 'CONFAB', color: COLORS.ghostPink },
      { name: 'DRIFT', color: COLORS.ghostPeach },
      { name: 'BIAS', color: COLORS.ghostMint },
      { name: 'PSYCHOSIS', color: COLORS.ghostYellow },
    ];

    ghostData.forEach((g, i) => {
      const gy = y + 60 + i * 80;
      Sprites.drawGhost(ctx, cx - 60, gy, 24, g.color, GHOST_MODE.CHASE, DIR.RIGHT, this.frame);
      ctx.fillStyle = g.color;
      ctx.font = '10px "Press Start 2P"';
      ctx.fillText(g.name, cx + 30, gy);
    });

    // Divider
    ctx.fillStyle = '#444';
    ctx.fillRect(80, y + 400, CANVAS_W - 160, 2);

    // Made with Codex
    ctx.fillStyle = COLORS.textCyan;
    ctx.font = '8px "Press Start 2P"';
    ctx.fillText('Made with Codex', cx, y + 460);

    // Nine Treasures Creamery
    ctx.fillStyle = COLORS.text;
    ctx.font = '7px "Press Start 2P"';
    ctx.fillText('Nine Treasures Creamery', cx, y + 510);
    ctx.fillText('x AI-Pilled Asians', cx, y + 535);
    ctx.fillText('in Tech', cx, y + 555);

    // === SPONSORS section ===
    // Divider
    ctx.fillStyle = '#FFD700';
    ctx.fillRect(80, y + 600, CANVAS_W - 160, 2);

    // "SPONSORED BY" header
    ctx.fillStyle = '#FFD700';
    ctx.font = '9px "Press Start 2P"';
    ctx.fillText('SPONSORED BY', cx, y + 640);

    // Sponsor logos in a grid (3 per row)
    const logoSize = 60;
    const logoPad = 18;
    const cols = 3;
    const gridW = cols * logoSize + (cols - 1) * logoPad;
    const startX = cx - gridW / 2 + logoSize / 2;
    const startY = y + 690;

    sponsorImages.forEach((s, i) => {
      const col = i % cols;
      const row = Math.floor(i / cols);
      const lx = startX + col * (logoSize + logoPad);
      const ly = startY + row * (logoSize + logoPad + 10);

      if (s.img.complete && s.img.naturalWidth > 0) {
        // Scale image to fit within logoSize while maintaining aspect ratio
        const imgAspect = s.img.naturalWidth / s.img.naturalHeight;
        let drawW, drawH;
        if (imgAspect > 1) {
          drawW = logoSize;
          drawH = logoSize / imgAspect;
        } else {
          drawH = logoSize;
          drawW = logoSize * imgAspect;
        }
        ctx.drawImage(s.img, lx - drawW / 2, ly - drawH / 2, drawW, drawH);
      }
    });

    // Total height of sponsor grid: 4 rows (11 logos, 3 per row = 4 rows)
    const totalRows = Math.ceil(sponsorImages.length / cols);
    const gridEndY = startY + totalRows * (logoSize + logoPad + 10);

    // Final divider after sponsors
    ctx.fillStyle = '#444';
    ctx.fillRect(80, gridEndY + 20, CANVAS_W - 160, 2);

    // Thank you text
    ctx.fillStyle = '#E8D5C7';
    ctx.font = '6px "Press Start 2P"';
    ctx.fillText('Thank you to our', cx, gridEndY + 60);
    ctx.fillText('amazing sponsors!', cx, gridEndY + 78);
  }

  renderScoreScreen() {
    const cx = CANVAS_W / 2;
    const cy = CANVAS_H / 2;
    const t = this.frame;

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // === Warm burgundy gradient background ===
    const bgGrad = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
    bgGrad.addColorStop(0, '#0a0003');
    bgGrad.addColorStop(0.3, '#1a0508');
    bgGrad.addColorStop(0.7, '#1a0508');
    bgGrad.addColorStop(1, '#0a0003');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

    // === Subtle warm particles ===
    for (let i = 0; i < 20; i++) {
      const px = ((i * 173 + t * 0.15) % CANVAS_W);
      const py = ((i * 113 + t * 0.08) % CANVAS_H);
      const twinkle = 0.2 + 0.4 * Math.abs(Math.sin(t * 0.02 + i));
      ctx.globalAlpha = twinkle;
      ctx.fillStyle = (i % 3 === 0) ? '#A42325' : '#FFD700';
      ctx.fillRect(Math.floor(px), Math.floor(py), 1, 1);
    }
    ctx.globalAlpha = 1;

    // === Decorative top border ===
    for (let i = 0; i < CANVAS_W; i += 10) {
      const glow = 0.25 + 0.15 * Math.sin(t * 0.04 + i * 0.12);
      ctx.globalAlpha = glow;
      ctx.fillStyle = '#A42325';
      ctx.fillRect(i + 3, 5, 3, 3);
      ctx.fillStyle = '#FFD700';
      ctx.fillRect(i + 4, 6, 1, 1);
    }
    ctx.globalAlpha = 1;

    // === "YOUR SCORE" header ===
    ctx.save();
    ctx.shadowColor = '#A42325';
    ctx.shadowBlur = 10;
    ctx.fillStyle = '#E8D5C7';
    ctx.font = '10px "Press Start 2P"';
    ctx.fillText('YOUR SCORE', cx, 40);
    ctx.restore();

    // === Score number — big and golden ===
    const scorePulse = 1 + 0.03 * Math.sin(t * 0.06);
    ctx.save();
    ctx.shadowColor = '#A42325';
    ctx.shadowBlur = 15;
    ctx.fillStyle = '#FFD700';
    ctx.font = `${Math.round(24 * scorePulse)}px "Press Start 2P"`;
    ctx.fillText('' + this.score, cx, 80);
    ctx.restore();

    // === Gold divider ===
    const lineW = 140;
    const divGrad = ctx.createLinearGradient(cx - lineW/2, 0, cx + lineW/2, 0);
    divGrad.addColorStop(0, 'rgba(164,35,37,0)');
    divGrad.addColorStop(0.3, 'rgba(255,215,0,0.6)');
    divGrad.addColorStop(0.5, 'rgba(255,215,0,1)');
    divGrad.addColorStop(0.7, 'rgba(255,215,0,0.6)');
    divGrad.addColorStop(1, 'rgba(164,35,37,0)');
    ctx.fillStyle = divGrad;
    ctx.fillRect(cx - lineW/2, 104, lineW, 2);

    // === Instagram CTA ===
    ctx.fillStyle = '#E8D5C7';
    ctx.font = '5px "Press Start 2P"';
    ctx.fillText('Screenshot & post to', cx, 130);
    ctx.fillText('Instagram Stories and tag', cx, 146);

    ctx.save();
    ctx.shadowColor = '#A42325';
    ctx.shadowBlur = 6;
    ctx.fillStyle = '#FFD700';
    ctx.font = '6px "Press Start 2P"';
    ctx.fillText('@ninetreasurescreamery', cx, 168);
    ctx.restore();

    // === Prize text ===
    ctx.fillStyle = '#E8D5C7';
    ctx.font = '5px "Press Start 2P"';
    ctx.fillText('The highest score', cx, 200);
    ctx.fillText('will win', cx, 216);

    ctx.save();
    ctx.shadowColor = '#FFD700';
    ctx.shadowBlur = 4;
    ctx.fillStyle = '#FFD700';
    ctx.font = '6px "Press Start 2P"';
    ctx.fillText('2 pints!', cx, 236);
    ctx.restore();

    // === Second divider ===
    const div2Grad = ctx.createLinearGradient(cx - lineW/2, 0, cx + lineW/2, 0);
    div2Grad.addColorStop(0, 'rgba(164,35,37,0)');
    div2Grad.addColorStop(0.5, 'rgba(164,35,37,0.6)');
    div2Grad.addColorStop(1, 'rgba(164,35,37,0)');
    ctx.fillStyle = div2Grad;
    ctx.fillRect(cx - lineW/2, 258, lineW, 1);

    // === Small ice cream icons as decoration ===
    const scoopColors = ['#D4A574', '#333333', '#C8A050', '#7CB342'];
    scoopColors.forEach((c, i) => {
      const ix = cx - 54 + i * 36;
      const bob = Math.sin(t * 0.04 + i * 1.5) * 2;
      Sprites.drawIceCream(ctx, ix, 278 + bob, 10, c);
    });

    // === "See Credits and Shout Outs" button ===
    const btnY = 318;
    const btnW = 260;
    const btnH = 28;
    const btnPulse = 0.7 + 0.3 * Math.sin(t * 0.07);

    // Button background
    ctx.save();
    ctx.globalAlpha = btnPulse;
    ctx.shadowColor = '#A42325';
    ctx.shadowBlur = 8;
    ctx.fillStyle = '#A42325';
    const btnR = 4;
    ctx.beginPath();
    ctx.moveTo(cx - btnW/2 + btnR, btnY - btnH/2);
    ctx.lineTo(cx + btnW/2 - btnR, btnY - btnH/2);
    ctx.quadraticCurveTo(cx + btnW/2, btnY - btnH/2, cx + btnW/2, btnY - btnH/2 + btnR);
    ctx.lineTo(cx + btnW/2, btnY + btnH/2 - btnR);
    ctx.quadraticCurveTo(cx + btnW/2, btnY + btnH/2, cx + btnW/2 - btnR, btnY + btnH/2);
    ctx.lineTo(cx - btnW/2 + btnR, btnY + btnH/2);
    ctx.quadraticCurveTo(cx - btnW/2, btnY + btnH/2, cx - btnW/2, btnY + btnH/2 - btnR);
    ctx.lineTo(cx - btnW/2, btnY - btnH/2 + btnR);
    ctx.quadraticCurveTo(cx - btnW/2, btnY - btnH/2, cx - btnW/2 + btnR, btnY - btnH/2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // Button border
    ctx.strokeStyle = '#FFD700';
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.5;
    ctx.beginPath();
    ctx.moveTo(cx - btnW/2 + btnR, btnY - btnH/2);
    ctx.lineTo(cx + btnW/2 - btnR, btnY - btnH/2);
    ctx.quadraticCurveTo(cx + btnW/2, btnY - btnH/2, cx + btnW/2, btnY - btnH/2 + btnR);
    ctx.lineTo(cx + btnW/2, btnY + btnH/2 - btnR);
    ctx.quadraticCurveTo(cx + btnW/2, btnY + btnH/2, cx + btnW/2 - btnR, btnY + btnH/2);
    ctx.lineTo(cx - btnW/2 + btnR, btnY + btnH/2);
    ctx.quadraticCurveTo(cx - btnW/2, btnY + btnH/2, cx - btnW/2, btnY + btnH/2 - btnR);
    ctx.lineTo(cx - btnW/2, btnY - btnH/2 + btnR);
    ctx.quadraticCurveTo(cx - btnW/2, btnY - btnH/2, cx - btnW/2 + btnR, btnY - btnH/2);
    ctx.closePath();
    ctx.stroke();
    ctx.globalAlpha = 1;

    // Button text
    ctx.fillStyle = '#E8D5C7';
    ctx.font = '5px "Press Start 2P"';
    ctx.fillText('See Credits and Shout Outs', cx, btnY);

    // === Bottom decorative border ===
    for (let i = 0; i < CANVAS_W; i += 10) {
      const glow = 0.25 + 0.15 * Math.sin(t * 0.04 + i * 0.12 + 2);
      ctx.globalAlpha = glow;
      ctx.fillStyle = '#A42325';
      ctx.fillRect(i + 3, CANVAS_H - 8, 3, 3);
      ctx.fillStyle = '#FFD700';
      ctx.fillRect(i + 4, CANVAS_H - 7, 1, 1);
    }
    ctx.globalAlpha = 1;
  }

  renderEnd() {
    const cx = CANVAS_W / 2;
    const cy = CANVAS_H / 2;
    const t = this.frame;

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // === Dark red/black gradient background ===
    const bgGrad = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
    bgGrad.addColorStop(0, '#1a0000');
    bgGrad.addColorStop(0.5, '#330000');
    bgGrad.addColorStop(1, '#1a0000');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

    // === Fireworks system ===
    if (!this.fireworks) this.fireworks = [];

    // Spawn new fireworks periodically
    if (t % 25 === 0 || t % 37 === 0 || t % 53 === 0) {
      const colors = ['#FF0000', '#FFD700', '#FF4500', '#FF69B4', '#00FFFF', '#FFE4B5', '#FFA500'];
      this.fireworks.push({
        x: 30 + Math.random() * (CANVAS_W - 60),
        y: 30 + Math.random() * (CANVAS_H * 0.5),
        color: colors[Math.floor(Math.random() * colors.length)],
        particles: Array.from({ length: 16 }, () => ({
          angle: Math.random() * Math.PI * 2,
          speed: 0.5 + Math.random() * 2,
          decay: 0.015 + Math.random() * 0.02,
        })),
        life: 1.0,
        age: 0,
      });
    }

    // Update and draw fireworks
    this.fireworks = this.fireworks.filter(fw => fw.life > 0);
    for (const fw of this.fireworks) {
      fw.age++;
      fw.life -= 0.012;
      for (const p of fw.particles) {
        const dist = p.speed * fw.age * 0.7;
        const px = fw.x + Math.cos(p.angle) * dist;
        const py = fw.y + Math.sin(p.angle) * dist + fw.age * 0.15; // slight gravity
        const size = Math.max(1, 3 * fw.life);
        ctx.globalAlpha = fw.life * (0.7 + 0.3 * Math.sin(t * 0.2 + p.angle));
        ctx.fillStyle = fw.color;
        ctx.fillRect(px - size/2, py - size/2, size, size);
        // Sparkle trail
        if (fw.life > 0.4) {
          ctx.globalAlpha = fw.life * 0.3;
          ctx.fillRect(px - 1, py - 1, 2, 2);
        }
      }
    }
    ctx.globalAlpha = 1;

    // === Decorative lantern dots along top and bottom ===
    for (let i = 0; i < CANVAS_W; i += 12) {
      const lanternGlow = 0.4 + 0.3 * Math.sin(t * 0.04 + i * 0.15);
      ctx.globalAlpha = lanternGlow;
      ctx.fillStyle = '#FF0000';
      ctx.fillRect(i + 4, 4, 4, 4);
      ctx.fillStyle = '#FFD700';
      ctx.fillRect(i + 5, 5, 2, 2);
      ctx.globalAlpha = lanternGlow * 0.7;
      ctx.fillStyle = '#FF0000';
      ctx.fillRect(i + 4, CANVAS_H - 8, 4, 4);
      ctx.fillStyle = '#FFD700';
      ctx.fillRect(i + 5, CANVAS_H - 7, 2, 2);
    }
    ctx.globalAlpha = 1;

    // === "HAPPY LUNAR NEW YEAR!" ===
    const lnyGlow = 0.6 + 0.4 * Math.sin(t * 0.05);
    ctx.save();
    ctx.shadowColor = '#FFD700';
    ctx.shadowBlur = 10 + lnyGlow * 6;
    ctx.fillStyle = '#FFD700';
    ctx.font = '8px "Press Start 2P"';
    ctx.fillText('HAPPY LUNAR', cx, 34);
    ctx.fillText('NEW YEAR!', cx, 52);
    ctx.restore();

    // === Gold decorative divider ===
    const lineW = 140;
    const divGrad = ctx.createLinearGradient(cx - lineW/2, 0, cx + lineW/2, 0);
    divGrad.addColorStop(0, 'rgba(255,215,0,0)');
    divGrad.addColorStop(0.3, 'rgba(255,0,0,0.8)');
    divGrad.addColorStop(0.5, 'rgba(255,215,0,1)');
    divGrad.addColorStop(0.7, 'rgba(255,0,0,0.8)');
    divGrad.addColorStop(1, 'rgba(255,215,0,0)');
    ctx.fillStyle = divGrad;
    ctx.fillRect(cx - lineW/2, 66, lineW, 2);

    // === Hanging lanterns (pixel art) ===
    const drawLantern = (lx, ly, size, phase) => {
      const sway = Math.sin(t * 0.03 + phase) * 2;
      const lxs = lx + sway;
      // String
      ctx.strokeStyle = '#8B4513';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(lx, ly - size);
      ctx.lineTo(lxs, ly);
      ctx.stroke();
      // Lantern body
      const glow = 0.7 + 0.3 * Math.sin(t * 0.06 + phase);
      ctx.globalAlpha = glow;
      ctx.fillStyle = '#FF0000';
      ctx.fillRect(lxs - size/2, ly, size, size * 1.3);
      // Gold trim
      ctx.fillStyle = '#FFD700';
      ctx.fillRect(lxs - size/2 - 1, ly, size + 2, 2);
      ctx.fillRect(lxs - size/2 - 1, ly + size * 1.3 - 2, size + 2, 2);
      // Inner glow
      ctx.fillStyle = '#FFA500';
      ctx.fillRect(lxs - size/4, ly + 3, size/2, size * 1.3 - 6);
      // Tassel
      ctx.fillStyle = '#FFD700';
      ctx.fillRect(lxs - 1, ly + size * 1.3, 2, size * 0.5);
      ctx.globalAlpha = 1;
    };

    drawLantern(40, 78, 12, 0);
    drawLantern(CANVAS_W - 40, 78, 12, 2);
    drawLantern(70, 85, 8, 1);
    drawLantern(CANVAS_W - 70, 85, 8, 3);

    // === "THE END" with red/gold glow ===
    const endPulse = 0.5 + 0.5 * Math.sin(t * 0.04);
    ctx.save();
    ctx.shadowColor = '#FF0000';
    ctx.shadowBlur = 12 + endPulse * 10;
    ctx.fillStyle = '#FFD700';
    ctx.font = '20px "Press Start 2P"';
    ctx.fillText('THE END', cx, cy + 10);
    ctx.restore();

    // Red outline text effect
    ctx.save();
    ctx.strokeStyle = '#FF0000';
    ctx.lineWidth = 1;
    ctx.font = '20px "Press Start 2P"';
    ctx.strokeText('THE END', cx, cy + 10);
    ctx.restore();

    // === Pac-Man and ghosts parade ===
    const paradeY = cy + 60;
    const paradeOffset = (t * 0.8) % (CANVAS_W + 200);
    const px = -100 + paradeOffset;
    Sprites.drawPacman(ctx, px, paradeY, 14, DIR.RIGHT, 0.15 + 0.35 * Math.abs(Math.sin(t * 0.12)));
    const ghostColors = [COLORS.ghostPink, COLORS.ghostPeach, COLORS.ghostMint, COLORS.ghostYellow];
    ghostColors.forEach((c, i) => {
      const gx = px - 22 - i * 20;
      const bob = Math.sin(t * 0.08 + i) * 2;
      Sprites.drawGhost(ctx, gx, paradeY + bob, 12, c, GHOST_MODE.FRIGHTENED, DIR.RIGHT, t + i * 10);
    });

    // === "PLAY AGAIN" button ===
    const playPulse = 1 + 0.06 * Math.sin(t * 0.1);
    const playAlpha = 0.6 + 0.4 * Math.sin(t * 0.08);
    ctx.save();
    ctx.globalAlpha = playAlpha;
    ctx.shadowColor = '#FFD700';
    ctx.shadowBlur = 6;
    ctx.fillStyle = '#FFD700';
    ctx.font = `${Math.round(10 * playPulse)}px "Press Start 2P"`;
    ctx.fillText('PLAY AGAIN', cx, CANVAS_H - 40);
    ctx.restore();

    // === Bottom gold divider ===
    const botGrad = ctx.createLinearGradient(cx - lineW/2, 0, cx + lineW/2, 0);
    botGrad.addColorStop(0, 'rgba(255,215,0,0)');
    botGrad.addColorStop(0.5, 'rgba(255,215,0,0.5)');
    botGrad.addColorStop(1, 'rgba(255,215,0,0)');
    ctx.fillStyle = botGrad;
    ctx.fillRect(cx - lineW/2, CANVAS_H - 18, lineW, 1);
  }
}

// ==========================================
// MAIN GAME LOOP
// ==========================================
const game = new Game();
let lastTime = 0;
let accumulator = 0;

function gameLoop(timestamp) {
  const dt = timestamp - lastTime;
  lastTime = timestamp;
  accumulator += dt;

  while (accumulator >= FRAME_TIME) {
    game.update();
    accumulator -= FRAME_TIME;
  }

  game.render();
  requestAnimationFrame(gameLoop);
}

// Wait for font to load, then start
document.fonts.ready.then(() => {
  requestAnimationFrame(gameLoop);
});
</script>
</body>
</html>
